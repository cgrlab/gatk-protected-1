package org.broadinstitute.hellbender.tools.exome;

import htsjdk.samtools.metrics.MetricsFile;
import htsjdk.variant.variantcontext.*;
import htsjdk.variant.variantcontext.writer.VariantContextWriter;
import htsjdk.variant.vcf.*;
import org.apache.commons.lang3.tuple.Pair;
import org.broadinstitute.hellbender.cmdline.Argument;
import org.broadinstitute.hellbender.cmdline.CommandLineProgramProperties;
import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;
import org.broadinstitute.hellbender.cmdline.programgroups.VariantProgramGroup;
import org.broadinstitute.hellbender.engine.FeatureContext;
import org.broadinstitute.hellbender.engine.ReadsContext;
import org.broadinstitute.hellbender.engine.ReferenceContext;
import org.broadinstitute.hellbender.engine.VariantWalker;
import org.broadinstitute.hellbender.exceptions.UserException;
import org.broadinstitute.hellbender.tools.exome.orientationbiasvariantfilter.ArtifactStatisticsScorer;
import org.broadinstitute.hellbender.tools.exome.orientationbiasvariantfilter.OxoQScorer;
import org.broadinstitute.hellbender.tools.picard.analysis.artifacts.SequencingArtifactMetrics;
import org.broadinstitute.hellbender.tools.walkers.annotator.VariantAnnotation;
import org.broadinstitute.hellbender.tools.walkers.annotator.VariantOverlapAnnotator;
import org.broadinstitute.hellbender.utils.genotyper.IndexedSampleList;
import org.broadinstitute.hellbender.utils.genotyper.SampleList;
import org.broadinstitute.hellbender.utils.variant.GATKVariantContextUtils;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.*;
import java.util.stream.Collectors;


// TODO:Command line property docs
@CommandLineProgramProperties(
        summary = "Note:  All variants are held in RAM.",
        oneLineSummary = "",
        programGroup = VariantProgramGroup.class
)
public class FilterByOrientationBias extends VariantWalker {

    public static final String PRE_ADAPTER_METRICS_DETAIL_FILE_SHORT_NAME = "P";
    public static final String PRE_ADAPTER_METRICS_DETAIL_FILE_FULL_NAME = "preAdapterDetailFile";
    public static final String ARTIFACT_MODES_SHORT_NAME = "A";
    public static final String ARTIFACT_MODES_FULL_NAME = "artifactModes";
    //TODO: Promote to GATKVCFConstants
    public static final String FOXOG_TAG = "FOXOG";

    @Argument(
            doc="Output Somatic SNP/Indel VCF file",
            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,
            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,
            optional = false)
    protected File outputFile;

    @Argument(
            doc = "PreAdapter Detail metrics file.  Usually, generated by CollectSequencingArtifactMetrics.",
            shortName = PRE_ADAPTER_METRICS_DETAIL_FILE_SHORT_NAME,
            fullName = PRE_ADAPTER_METRICS_DETAIL_FILE_FULL_NAME,
            optional = false)
    protected File preAdapterMetricsFile;

    @Argument(
            doc = "PreAdapter Detail artifacts of interest on the forward strand.  'C/A' for a single artifact.  Separated by commas to assume multiple artifacts at the same time:  'C/A,T/G'  Artifacts must be one base to one base (e.g. 'CC/CA' is illegal).  C>A is OxoG.",
            shortName = ARTIFACT_MODES_SHORT_NAME,
            fullName = ARTIFACT_MODES_FULL_NAME,
            optional = true
    )
    protected List<String> artifactModes = Collections.singletonList("C/A");

    private Map<VariantAnnotation, VariantOverlapAnnotator> annotators;

    private Map<Pair<Character, Character>, Double> oxoQScoreMap;

    private List<Pair<Character, Character>> relevantArtifactModes;

    public final String OXOQ_FIELD_NAME="OxoQ";
    public final String P_ARTIFACT_FIELD_NAME="P_artifact";

    public final Double OXOQ_NOT_ARTIFACT_SCORE=100.0;
    public final double BIASP=0.96;

    private VariantContextWriter vcfWriter;

    /** Each has an OxoQ annotation */
    private List<VariantContext> firstPassVariants;
    private List<VariantContext> unfilteredArtifactModeVariants;


    @Override
    public void onTraversalStart() {

        final MetricsFile<SequencingArtifactMetrics.PreAdapterDetailMetrics, Comparable<?>> mf = new MetricsFile<>();

        try {
            mf.read(new FileReader(preAdapterMetricsFile));
        } catch (final FileNotFoundException fnfe) {
            throw new UserException("Could not find file: " + preAdapterMetricsFile.getAbsolutePath());
        }

        firstPassVariants = new ArrayList<>();
        unfilteredArtifactModeVariants = new ArrayList<>();

        // Get the OxoQ score, which gives an indication of how badly infested the file is.
        oxoQScoreMap = OxoQScorer.scoreOrientationBiasMetricsOverContext(mf.getMetrics());

        // Parse the desired artifact modes from the input string.
        relevantArtifactModes  = new ArrayList<>();
        for (String artifactMode: artifactModes) {
            final String[] splitArtifactMode = artifactMode.split("/");

            if (!isValidArtifactMode(splitArtifactMode)) {
                throw new UserException("Invalid artifact mode: " + String.join("/", splitArtifactMode));
            }

            relevantArtifactModes.add(Pair.of(splitArtifactMode[0].charAt(0), splitArtifactMode[1].charAt(0)));
        }

        setupVCFWriter();
    }

    private boolean isValidArtifactMode(final String[] splitArtifactMode) {
        // TODO: Fill this in.
        return true;
    }

    /**
     *  Just adds the OxoQ annotation to the variant and creates a new variant.
     *
     *  Note: the writing of the VCF is not done here, since we need to aggregate once we have OxoQ scores.
     *  Note:  No variant is dropped, if no additional annotation was needed, then the original format field is
     *   preserved
     * @param variant See {@link VariantWalker}
     * @param readsContext See {@link VariantWalker}
     * @param referenceContext See {@link VariantWalker}
     * @param featureContext See {@link VariantWalker}
     */
    @Override
    public void apply(VariantContext variant, ReadsContext readsContext, ReferenceContext referenceContext, FeatureContext featureContext) {
        VariantContextBuilder variantBuilder = new VariantContextBuilder(variant);
        GenotypesContext genotypesContext = variant.getGenotypes();

        final List<Genotype> newGenotypes = new ArrayList<>();
        for (Genotype genotype: genotypesContext.iterateInSampleNameOrder()) {
            final GenotypeBuilder genotypeBuilder = new GenotypeBuilder(genotype);

            final List<Allele> alleles = genotype.getAlleles();

            // Get the reference allele as a String
            final List<String> refAlleles = alleles.stream().filter(a -> a.isReference()).map(a -> a.getBaseString()).collect(Collectors.toList());
            if (!((refAlleles.size() != 1) || (refAlleles.get(0).length() != 1))) {
                final Character refAllele = (char) refAlleles.get(0).getBytes()[0];
                for (int i = 1; i < alleles.size(); i ++ ) {
                    final Allele allele = genotype.getAllele(i);
                    if (allele.isCalled() && allele.isNonReference() && !allele.equals(Allele.SPAN_DEL)
                            && allele.getBaseString().length() == 1) {
                        genotypeBuilder.attribute(OXOQ_FIELD_NAME, oxoQScoreMap.getOrDefault(Pair.of(refAllele, allele.getBaseString().charAt(0)), OXOQ_NOT_ARTIFACT_SCORE));

                        final int totalAltAlleleCount = genotype.getAD()[i];
                        final Double foxog = Double.parseDouble((String) genotype.getAnyAttribute(FOXOG_TAG));
                        genotypeBuilder.attribute(P_ARTIFACT_FIELD_NAME, ArtifactStatisticsScorer.calculateArtifactPValue(totalAltAlleleCount, (int) Math.round(foxog * totalAltAlleleCount), BIASP));
                    }
                }
            }
            newGenotypes.add(genotypeBuilder.make());
        }
        variantBuilder.genotypes(newGenotypes);
        final VariantContext updatedVariant = variantBuilder.make();
        firstPassVariants.add(updatedVariant);
    }

    private void setupVCFWriter() {

        // Setup header for output file
        final VCFHeader inputVCFHeader = getHeaderForVariants();
        final Set<VCFHeaderLine> headerLines = new LinkedHashSet<>(inputVCFHeader.getMetaDataInInputOrder());
        headerLines.add(new VCFFormatHeaderLine(OXOQ_FIELD_NAME, VCFHeaderLineCount.A, VCFHeaderLineType.Float, "Measure of orientation bias for a given REF/ALT error."));
        headerLines.add(new VCFFormatHeaderLine(P_ARTIFACT_FIELD_NAME, VCFHeaderLineCount.A, VCFHeaderLineType.Float, "orientation bias p value for the given REF/ALT artifact."));
        headerLines.add(new VCFSimpleHeaderLine("orientation_bias_artifact_modes", String.join(",", artifactModes), "The artifact modes that were used for orientation bias artifact filtering for this VCF"));
        headerLines.add(new VCFHeaderLine("command", getCommandLine()));
        vcfWriter = GATKVariantContextUtils.createVCFWriter(outputFile, getReferenceDictionary(), false);
        final SampleList samples = new IndexedSampleList(inputVCFHeader.getGenotypeSamples());
        final Set<String> sampleNameSet = samples.asSetOfSamples();
        final VCFHeader vcfHeader = new VCFHeader(headerLines, sampleNameSet);
        vcfWriter.writeHeader(vcfHeader);
    }

    @Override
    public Object onTraversalSuccess() {

        final Comparator<VariantContext> variantContextPArtifactComparator = new Comparator<VariantContext>() {
            @Override
            public int compare(VariantContext o1, VariantContext o2) {
                final Double o1PArtifact = (Double) o1.getAttribute(P_ARTIFACT_FIELD_NAME, 0.0);
                final Double o2PArtifact = (Double) o2.getAttribute(P_ARTIFACT_FIELD_NAME, 0.0);
                if (o2PArtifact.equals(o1PArtifact)) {
                    return 0;
                } else if (o1PArtifact > o2PArtifact) {
                    return 1;
                } else {
                    return -1;
                }
            }
        };

        // Grab unfiltered variants only


        final SortedSet<VariantContext> sortedVariants = new TreeSet<>(variantContextPArtifactComparator);

        sortedVariants.addAll(firstPassVariants);

        // Calculate how many artifacts need to be cut

        // Annotate the filtering for each variant

        return null;
    }

    @Override
    public void closeTool() {
        if ( vcfWriter != null) {
            vcfWriter.close();
        }
    }
}
